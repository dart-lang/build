import 'dart:async';
import 'dart:convert';

import 'package:build/build.dart';
import 'package:path/path.dart' as path;

import '../errors.dart';
import 'asset_filter.dart';
import 'file_system.dart';

/// An [AssetReader] tailored to bazel.
///
/// This allows specifying file paths via [loadAssetsByPath]. This will try to
/// determine the appropriate [AssetId] for each input and use the provided path
/// for that [AssetId] if it is requested. This allows us to use files which are
/// generated by earlier bazel rules.
class BazelAssetReader implements AssetReader {
  /// The path to the package we are currently processing.
  final String packagePath;

  final _assetCache = <AssetId, String>{};

  /// The google-specific file system.
  ///
  /// Responsible for knowing where bazel stores source and generated files on
  /// disk.
  final BazelFileSystem _fileSystem;

  /// A filter for which assets are allowed to be read.
  final AssetFilter _assetFilter;

  final Map<String, String> _packageMap;

  int numAssetsReadFromDisk = 0;

  BazelAssetReader._(
      this.packagePath, Iterable<String> rootDirs, this._packageMap,
      {AssetFilter assetFilter})
      : _fileSystem = new BazelFileSystem('.', rootDirs),
        _assetFilter = assetFilter;

  factory BazelAssetReader(String packagePath, Iterable<String> rootDirs,
      Map<String, String> packageMap,
      {AssetFilter assetFilter}) {
    if (packagePath.endsWith('/') || packagePath.endsWith('\\')) {
      packagePath = packagePath.substring(0, packagePath.length - 1);
    }
    return new BazelAssetReader._(packagePath, rootDirs, packageMap,
        assetFilter: assetFilter);
  }

  BazelAssetReader.forTest(this.packagePath, this._packageMap, this._fileSystem)
      : _assetFilter = const _AllowAllAssets();

  /// Primes the reader with the files in `inputs`.
  ///
  /// Creates and returns a map from the file path on disk to the file's
  /// [AssetId] for each file in `inputs`.
  Map<String, AssetId> loadAssetsByPath(Iterable<String> inputs) =>
      translateToAssetIds(inputs, packagePath, _packageMap);

  /// Primes the cache with [assets].
  void cacheAssets(Map<AssetId, String> assets) {
    _assetCache.addAll(assets);
  }

  @override
  Future<String> readAsString(AssetId id, {Encoding encoding: UTF8}) async {
    final packagePath = _packageMap[id.package];
    if (!_assetFilter.isValid(id) || packagePath == null) {
      throw new CodegenError('Attempted to read invalid input $id.');
    }
    final filePath = path.join(packagePath, id.path);

    if (_assetCache.containsKey(id)) {
      return _assetCache[id];
    }

    numAssetsReadFromDisk++;
    final contents = _fileSystem.readAsStringSync(filePath);
    if (contents == null) {
      throw new CodegenError('Could not find $id at $filePath');
    }
    _assetCache[id] = contents;
    return contents;
  }

  @override
  Future<bool> hasInput(AssetId id) async {
    final packagePath = _packageMap[id.package];
    if (packagePath == null) return false;
    final filePath = path.join(packagePath, id.path);
    if (!_assetFilter.isValid(id)) {
      return false;
    }
    return _assetCache.containsKey(id) || _fileSystem.existsSync(filePath);
  }
}

String _findPackageName(Map<String, String> packageMap, String packagePath) {
  for (var packageName in packageMap.keys) {
    if (packageMap[packageName] == packagePath) {
      return packageName;
    }
  }
  throw new CodegenError('Could not find package name for path $packagePath');
}

Map<String, AssetId> translateToAssetIds(Iterable<String> inputs,
    String packagePath, Map<String, String> packageMap) {
  final map = <String, AssetId>{};
  final packageName = _findPackageName(packageMap, packagePath);
  for (var input in inputs) {
    if (!input.startsWith(packagePath)) {
      throw new CodegenError(
          'Cannot generate files for source "$input" because it is not '
          'in the current package ($packagePath). '
          'If this file is needed to generate other files, please add it to '
          'the `src_deps` of this rule');
    }
    map[input] =
        new AssetId(packageName, input.substring(packagePath.length + 1));
  }
  return map;
}

class _AllowAllAssets implements AssetFilter {
  const _AllowAllAssets();
  @override
  bool isValid(AssetId id) => true;
}
