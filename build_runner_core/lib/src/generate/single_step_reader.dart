// Copyright (c) 2017, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

import 'dart:async';
import 'dart:convert';

import 'package:async/async.dart';
import 'package:build/build.dart';
// ignore: implementation_imports
import 'package:build/src/internal.dart';
import 'package:crypto/crypto.dart';
import 'package:glob/glob.dart';

import '../asset_graph/graph.dart';
import '../asset_graph/node.dart';
import '../package_graph/package_graph.dart';
import '../package_graph/target_graph.dart';
import 'input_tracker.dart';
import 'phase.dart';

/// Builds an asset.
typedef AssetBuilder = Future<void> Function(AssetNode);

/// Builds a "glob node": all assets matching a glob.
typedef GlobNodeBuilder = Future<void> Function(GlobAssetNode);

/// Describes if and how a [SingleStepReader] should read an [AssetId].
class Readability {
  final bool canRead;
  final bool inSamePhase;

  const Readability({required this.canRead, required this.inSamePhase});

  /// Determines readability for a node written in a previous build phase, which
  /// means that [ownOutput] is impossible.
  factory Readability.fromPreviousPhase(bool readable) =>
      readable ? Readability.readable : Readability.notReadable;

  static const Readability notReadable = Readability(
    canRead: false,
    inSamePhase: false,
  );
  static const Readability readable = Readability(
    canRead: true,
    inSamePhase: false,
  );
  static const Readability ownOutput = Readability(
    canRead: true,
    inSamePhase: true,
  );
}

/// An [AssetReader] with a lifetime equivalent to that of a single step in a
/// build.
///
/// A step is a single Builder and primary input (or package for package
/// builders) combination.
///
/// Limits reads to the assets which are sources or were generated by previous
/// phases.
///
/// Tracks the assets and globs read during this step for input dependency
/// tracking.
class SingleStepReader extends AssetReader implements AssetReaderState {
  @override
  late final AssetFinder assetFinder = FunctionAssetFinder(_findAssets);

  final PackageGraph? _packageGraph;
  final TargetGraph? _targetGraph;
  final BuildPhase? _buildPhase;
  final AssetBuilder? _nodeBuilder;
  final GlobNodeBuilder? _globNodeBuilder;
  final AssetGraph? _assetGraph;
  final AssetReader _delegate;
  final int _phaseNumber;
  final String? _primaryPackage;
  final AssetWriterSpy? _writtenAssets;

  final InputTracker inputTracker;

  SingleStepReader(
    this._packageGraph,
    this._targetGraph,
    this._buildPhase,
    this._nodeBuilder,
    this._globNodeBuilder,
    this._delegate,
    this._assetGraph,
    this._phaseNumber,
    this._primaryPackage,
    this.inputTracker, [
    this._writtenAssets,
  ]);

  @override
  SingleStepReader copyWith({
    AssetPathProvider? assetPathProvider,
    FilesystemCache? cache,
  }) => SingleStepReader(
    _packageGraph,
    _targetGraph,
    _buildPhase,
    _nodeBuilder,
    _globNodeBuilder,
    _delegate.copyWith(assetPathProvider: assetPathProvider, cache: cache),
    _assetGraph,
    _phaseNumber,
    _primaryPackage,
    inputTracker,
    _writtenAssets,
  );

  /// Returns [reader] if it's already a [SingleStepReader], or wraps in one.
  ///
  /// When wrapping, `SingleStepReader` skips most functionality. For example,
  /// it has no [AssetGraph], so readability checks against the graph are not
  /// done. It still provides tracking of reads in [inputTracker].
  ///
  /// TODO(davidmorgan): this is just here to support testing, can it be
  /// removed by unifying test and non-test codepaths?
  static SingleStepReader wrapIfNeeded(AssetReader reader) {
    if (reader is SingleStepReader) return reader;
    return SingleStepReader(
      null,
      null,
      null,
      null,
      null,
      reader,
      null,
      -1,
      null,
      InputTracker(reader.filesystem),
      null,
    );
  }

  @override
  Filesystem get filesystem => _delegate.filesystem;

  @override
  FilesystemCache get cache => _delegate.cache;

  @override
  AssetPathProvider get assetPathProvider => _delegate.assetPathProvider;

  /// Checks whether [id] can be read by this step - attempting to build the
  /// asset if necessary.
  ///
  /// If [catchInvalidInputs] is set to true and [_checkInvalidInput] throws an
  /// [InvalidInputException], this method will return `false` instead of
  /// throwing.
  Future<bool> _isReadable(
    AssetId id, {
    bool catchInvalidInputs = false,
  }) async {
    try {
      _checkInvalidInput(id);
    } on InvalidInputException {
      if (catchInvalidInputs) return false;
      rethrow;
    } on PackageNotFoundException {
      if (catchInvalidInputs) return false;
      rethrow;
    }

    if (_assetGraph == null) {
      inputTracker.add(id);
      return _delegate.canRead(id);
    }

    final node = _assetGraph.get(id);
    if (node == null) {
      inputTracker.add(id);
      _assetGraph.add(SyntheticSourceAssetNode(id));
      return false;
    }

    final readability = await _isReadableNode(node);

    // If it's in the same phase it's never an input: it is either an output of
    // the current generator, which means it's readable but not an input, or
    // it's an output of a generator running in parallel, which means it's
    // hidden and can't be an input.
    if (!readability.inSamePhase) {
      inputTracker.add(id);
    }

    return readability.canRead;
  }

  @override
  Future<bool> canRead(AssetId id) async {
    final isReadable = await _isReadable(id, catchInvalidInputs: true);
    if (!isReadable) return false;

    // No need to check readability for [GeneratedAssetNode], they are always
    // readable.
    final nodeIsGeneratedNode =
        _assetGraph != null && _assetGraph.get(id) is GeneratedAssetNode;
    if (nodeIsGeneratedNode && !await _delegate.canRead(id)) {
      return false;
    }

    // If digests can be cached, cache it.
    // TODO(davidmorgan): remove?
    if (_assetGraph != null) await _ensureDigest(id);
    return true;
  }

  @override
  Future<Digest> digest(AssetId id) async {
    final isReadable = await _isReadable(id);

    if (!isReadable) {
      throw AssetNotFoundException(id);
    }
    return _ensureDigest(id);
  }

  @override
  Future<List<int>> readAsBytes(AssetId id) async {
    final isReadable = await _isReadable(id);
    if (!isReadable) {
      throw AssetNotFoundException(id);
    }
    await _ensureDigest(id);
    return _delegate.readAsBytes(id);
  }

  @override
  Future<String> readAsString(AssetId id, {Encoding encoding = utf8}) async {
    final isReadable = await _isReadable(id);
    if (!isReadable) {
      throw AssetNotFoundException(id);
    }
    await _ensureDigest(id);
    return _delegate.readAsString(id, encoding: encoding);
  }

  // This is only for generators, so only `BuildStep` needs to implement it.
  @override
  Stream<AssetId> findAssets(Glob glob) => throw UnimplementedError();

  Stream<AssetId> _findAssets(Glob glob, String? package) {
    if (_assetGraph == null) {
      return _delegate.assetFinder.find(glob, package: package);
    }

    var streamCompleter = StreamCompleter<AssetId>();

    _buildGlobNode(glob).then((globNode) {
      inputTracker.add(globNode.id);
      streamCompleter.setSourceStream(Stream.fromIterable(globNode.results!));
    });
    return streamCompleter.stream;
  }

  /// Returns the `lastKnownDigest` of [id], computing and caching it if
  /// necessary.
  ///
  /// Note that [id] must exist in the asset graph.
  FutureOr<Digest> _ensureDigest(AssetId id) {
    if (_assetGraph == null) return _delegate.digest(id);
    var node = _assetGraph.get(id)!;
    if (node.lastKnownDigest != null) return node.lastKnownDigest!;
    return _delegate.digest(id).then((digest) => node.lastKnownDigest = digest);
  }

  /// Checks whether [node] can be read by this step.
  ///
  /// If it's a generated node from an earlier phase, wait for it to be built.
  Future<Readability> _isReadableNode(AssetNode node) async {
    if (node is GeneratedAssetNode) {
      if (node.phaseNumber > _phaseNumber) {
        return Readability.notReadable;
      } else if (node.phaseNumber == _phaseNumber) {
        // allow a build step to read its outputs (contained in writtenAssets)
        final isInBuild =
            _buildPhase is InBuildPhase &&
            (_writtenAssets?.assetsWritten.contains(node.id) ?? true);

        return isInBuild ? Readability.ownOutput : Readability.notReadable;
      }

      await _nodeBuilder!.call(node);
      return Readability.fromPreviousPhase(node.wasOutput && !node.isFailure);
    }
    return Readability.fromPreviousPhase(node.isReadable && node.isValidInput);
  }

  void _checkInvalidInput(AssetId id) {
    if (_packageGraph == null) return;

    final packageNode = _packageGraph[id.package];
    if (packageNode == null) {
      throw PackageNotFoundException(id.package);
    }

    if (_targetGraph == null) return;

    // The id is an invalid input if it's not part of the build.
    if (!_targetGraph.isVisibleInBuild(id, packageNode)) {
      final allowed = _targetGraph.validInputsFor(packageNode);

      throw InvalidInputException(id, allowedGlobs: allowed);
    }
  }

  /// Builds a [GlobAssetNode] for [glob].
  ///
  /// Retrieves an existing node from [_assetGraph] it's available; if not, adds
  /// one. Then, waits for [_globNodeBuilder] to build it.
  Future<GlobAssetNode> _buildGlobNode(Glob glob) async {
    var globNodeId = GlobAssetNode.createId(
      _primaryPackage!,
      glob,
      _phaseNumber,
    );
    var globNode = _assetGraph!.get(globNodeId) as GlobAssetNode?;
    if (globNode == null) {
      globNode = GlobAssetNode(
        globNodeId,
        glob,
        _phaseNumber,
        NodeState.definitelyNeedsUpdate,
      );
      _assetGraph.add(globNode);
    }
    await _globNodeBuilder!.call(globNode);
    return globNode;
  }
}
