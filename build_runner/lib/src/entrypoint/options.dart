// Copyright (c) 2017, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.
import 'dart:async';
import 'dart:io';

import 'package:args/args.dart';
import 'package:args/command_runner.dart';
import 'package:build_runner/build_runner.dart';
import 'package:logging/logging.dart';
import 'package:meta/meta.dart';
import 'package:shelf/shelf_io.dart';

const _assumeTty = 'assume-tty';
const _deleteFilesByDefault = 'delete-conflicting-outputs';

/// Unified command runner for all build_runner commands.
class BuildCommandRunner extends CommandRunner {
  final List<BuilderApplication> builderApplications;

  BuildCommandRunner(List<BuilderApplication> builderApplications)
      : this.builderApplications = new List.unmodifiable(builderApplications),
        super('build_runner', 'Unified interface for running Dart builds.') {
    addCommand(new _BuildCommand());
    addCommand(new _WatchCommand());
    addCommand(new _ServeCommand());
  }
}

/// Base ptions that are shared among all commands.
class _SharedOptions {
  /// Skip the `stdioType()` check and assume the output is going to a terminal
  /// and that we can accept input on stdin.
  final bool assumeTty;

  /// By default, the user will be prompted to delete any files which already
  /// exist but were not generated by this specific build script.
  ///
  /// This option can be set to `true` to skip this prompt.
  final bool deleteFilesByDefault;

  _SharedOptions._(
      {@required this.assumeTty, @required this.deleteFilesByDefault});

  factory _SharedOptions.fromParsedArgs(ArgResults argResults) {
    return new _SharedOptions._(
        assumeTty: argResults[_assumeTty] as bool,
        deleteFilesByDefault: argResults[_deleteFilesByDefault] as bool);
  }
}

abstract class _BaseCommand extends Command {
  List<BuilderApplication> get builderApplications =>
      (runner as BuildCommandRunner).builderApplications;

  _BaseCommand() {
    argParser
      ..addFlag(_assumeTty,
          help: 'Enables colors and interactive input when the script does not'
              ' appear to be running directly in a terminal, for instance when it'
              ' is a subprocess',
          defaultsTo: null,
          negatable: true)
      ..addFlag(_deleteFilesByDefault,
          help:
              'By default, the user will be prompted to delete any files which '
              'already exist but were not known to be generated by this '
              'specific build script.\n\n'
              'Enabling this option skips the prompt and deletes the files. '
              'This should typically be used in continues integration servers '
              'and tests, but not otherwise.',
          negatable: false,
          defaultsTo: false);
  }

  /// Must be called inside [run] so that [argResults] is non-null.
  ///
  /// You may override this to return more specific options if desired, but they
  /// must extend [_SharedOptions].
  _SharedOptions _readOptions() =>
      new _SharedOptions.fromParsedArgs(argResults);
}

/// A [Command] that does a single build and then exits.
class _BuildCommand extends _BaseCommand {
  @override
  String get name => 'build';

  @override
  String get description =>
      'Performs a single build on the specified targets and then exits.';

  @override
  Future<Null> run() async {
    var options = _readOptions();
    await build(builderApplications,
        deleteFilesByDefault: options.deleteFilesByDefault,
        assumeTty: options.assumeTty);
  }
}

/// A [Command] that does watches the file system for updates and rebuilds as
/// appropriate.
class _WatchCommand extends _BaseCommand {
  @override
  String get name => 'watch';

  @override
  String get description =>
      'Builds the specified targets, watching the file system for updates and '
      'rebuilding as appropriate.';

  @override
  Future<Null> run() async {
    var options = _readOptions();
    var handler = await watch(builderApplications,
        deleteFilesByDefault: options.deleteFilesByDefault,
        assumeTty: options.assumeTty);
    await handler.currentBuild;
    await handler.buildResults.drain();
  }
}

/// Extends [_WatchCommand] with dev server functionality.
class _ServeCommand extends _WatchCommand {
  @override
  String get name => 'serve';

  @override
  String get description =>
      'Runs a development server that serves the specified targets and runs '
      'builds based on file system updates.';

  final logger = new Logger('Serve');

  @override
  Future<Null> run() async {
    var options = _readOptions();
    var handler = await watch(builderApplications,
        deleteFilesByDefault: options.deleteFilesByDefault,
        assumeTty: options.assumeTty);
    var server = await serve(handler.handlerFor('web'), 'localhost', 8000);
    await handler.currentBuild;
    stdout.writeln('Serving `web` on port 8000\n');
    await handler.buildResults.drain();
    await server.close();
  }
}
